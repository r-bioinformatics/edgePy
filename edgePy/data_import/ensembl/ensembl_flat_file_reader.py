from smart_open import smart_open  # type: ignore
from typing import Optional, Union, Dict, Hashable, Any, List
from pathlib import Path


class CanonicalDataStore(object):
    """
    A simple tool for reading canonical data, generated from the canonical_transcripts.py script provided with edgePy.

    Args:
        transcript_filename: the name of the transcript file, generated by canonical_transcripts.py
        symbols_filename: the name of the gene symbol file, generated by canonical_transcripts.py

    """

    def __init__(
        self, transcript_filename: Union[str, Path], symbols_filename: Union[str, Path]
    ) -> None:

        self.by_transcript: Dict[Hashable, Dict[Hashable, Any]] = {}
        self.canonical_transcript: Dict[Hashable, str] = {}

        self.gene_to_symbol: Dict[Hashable, str] = {}
        self.symbol_to_genes: Dict[Hashable, List] = {}

        with smart_open(transcript_filename, 'r') as data:
            for line in data:
                gene_info = line.strip().split("\t")
                gene = gene_info[0]
                transcript = gene_info[1]
                length = int(gene_info[2])
                canonical = True if gene_info[3] == "True" else False

                self.by_transcript[transcript] = {'len': length, 'can': canonical}

                if canonical:
                    self.canonical_transcript[gene] = transcript

        with smart_open(symbols_filename, 'r') as data:
            for line in data:
                symbol_info = line.strip().split("\t")
                symbol = symbol_info[0]
                gene = symbol_info[1]

                if gene not in self.gene_to_symbol:
                    self.gene_to_symbol[gene] = symbol

                if symbol not in self.symbol_to_genes:
                    self.symbol_to_genes[symbol] = []
                if gene not in self.symbol_to_genes[symbol]:
                    self.symbol_to_genes[symbol].append(gene)

    def has_gene(self, gene: Optional[str]) -> bool:
        """
        Check if a gene is present in the dataset.
        Args:
            gene: the ensembl gene id.
        """
        if gene and gene in self.canonical_transcript:
            return True
        else:
            return False

    def get_symbol_from_gene(self, gene: Optional[str]) -> Optional[str]:
        """
        Given a gene name, get the symbol - should give you the default ENSEMBL name, and not a synonym.
        Args:
            gene: the ensembl gene id.
        """
        if not gene:
            return None
        try:
            return self.gene_to_symbol[gene]
        except KeyError:
            print(f"gene {gene} not found in gene to symbol.")
            raise KeyError

    def get_genes_from_symbol(self, symbol: str) -> List:
        """
        Given the gene symbol (or a recognized synonym), get the ensembl id.
        Args:
            symbol: HUGO or HGNC symbol
        """

        try:
            return self.symbol_to_genes[symbol]
        except KeyError:
            return []

    @staticmethod
    def pick_gene_id(gene_ids: List) -> Optional[str]:
        """
        Where there are more than one gene ID for a symbol, pick the one with the largest ensembl ID integer.
        Args:
            gene_ids: list of gene IDs.
        """
        if not gene_ids:
            return None
        length = len(gene_ids)
        if length == 1:
            return gene_ids[0]
        else:
            gene_ids.sort(reverse=True)
            return gene_ids[0]

    def is_known_symbol(self, symbol: str) -> bool:
        """
        Check to see if we recognize a given symbol - there always will be things we don't recognize.
        Args:
            symbol: what you think is a gene symbol.
        """
        if symbol in self.symbol_to_genes:
            return True
        return False

    def is_known_gene(self, gene: str) -> bool:
        """
        Check to see if we can recognize a given gene ID from ENSEMBL.  If you have one that isn't recognized, it might
        belong to a different version.
        Args:
            gene: what you think is a gene id.
        :return:
        """
        if gene in self.gene_to_symbol:
            return True
        return False

    def is_canonical_by_transcript(self, transcript_id: str) -> bool:
        """
        Return a boolean indicating whether the supplied transcript is canonical or not.

        Args:
            transcript_id: an Ensembl transcript ID, starting with ENST
        """

        if transcript_id not in self.by_transcript:
            return False
        else:
            return self.by_transcript[transcript_id]['can']

    def get_canonical_transcript(self, gene_id: str) -> Optional[str]:
        """
        Return the Ensembl canonical transcript ID, given an ensembl transcript ID.

        Args:
            gene_id: An Ensembl gene ID, starting with ENSG
        """

        if gene_id in self.canonical_transcript:
            return self.canonical_transcript[gene_id]
        else:
            return None

    def get_length_of_transcript(self, transcript_id: str) -> int:
        """
        Return the length of a transcript, given an ensembl transcript ID.

        Args:
             transcript_id: an Ensembl transcript ID, starting with ENST
        """
        if transcript_id not in self.by_transcript:
            return False
        else:
            return self.by_transcript[transcript_id]['len']

    def get_length_of_canonical_transcript(self, gene_id: Optional[str]) -> int:
        """
        Return the length of a transcript, given an ensembl gene ID.

        Args:
             gene_id: An Ensembl gene ID, starting with ENSG
        """
        if not gene_id:
            return 0

        transcript_id = self.get_canonical_transcript(gene_id)

        if not transcript_id or transcript_id not in self.by_transcript:
            return False
        else:
            return self.by_transcript[transcript_id]['len']
